# The IR Specification (v0.0.1)

Note: This specification is unstable, and prone to changes as the language and the  
compiler evolve over time.

The IR (Intermediate Representation) generated by the GenIRXXX() functions in src/irgen.c,
targets a imaginary machine (IRM) with upto 2^32 - 1 virtual registers. It is heavily based off
of LLVM IR, and the IRM is also a RISC machine, which only allows operations on data present
in only its registers, and all data must be fetched from memory before they are modified, and
stored back, when done.

At the moment, we define the following instructions:
new <size> 
Allocate a block of memory of `size` bytes.
It is unspecified whether this memory is allocated from the stack or the heap. 
Returns a reference to the allocated memory, which can be loaded from or stored into.
new does not initialize the memory, and the memory it returns will be 
in an undefined state unless something is stored into it.

Arguments:
size = A constant integer with the following constraints 0 < size < 2^32 - 1

store <vreg> <size> <offset> <value>
Store into virtual register <vreg>, a <value> of size <size> bytes, 
at offset <offset>.

Arguments:
vreg = A virtual register holding a reference to a block of memory (e.g t0, t1, etc.)
size = Size in bytes of how much to store into vreg
offset = offset from the beginning of the memory block pointed to by `vreg`, to store into
value = A virtual register holding the value to store into

Note: 
1) If value does not hold an entity that is at least size bytes in length, the 
contents of the range [vreg + offset + size(value), vreg + size`] is undefined.
2) If size > sizeof(value) => behaviour is undefined
3) If sizeof(vreg) < size => behaviour is undefined
